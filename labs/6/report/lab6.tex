\documentclass{article}

\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units

\usepackage{graphicx} % Required for the inclusion of images

\usepackage{tabularx} % Tables

\usepackage{natbib} % Required to change bibliography style to APA

\usepackage{amsmath} % Required for some math elements

\usepackage{parskip} % Formatting

\usepackage{tikz}
\usetikzlibrary{automata,positioning} %for nodes

% Many options for pseudocode
\usepackage{algorithm2e}
\usepackage{algorithmic}

\usepackage[demo]{graphicx}
\usepackage{caption}
\usepackage{subcaption}

\usepackage{listings} % Python code blocks

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\title{Lab 6 Report: Path Planning} % Title

\author{Team 4 \\\\ Rohan Wagh \\ Oliver Rayner \\ Gabriel Jimenez \\ Kairo Morton \\\\ 6.4200/16.405: Robotics Science and Systems} % Team # + Names, Class (RSS)

\date{\today} % Date for the report

\begin{document}

\maketitle

\section{Introduction}


\section{Technical Approach}

As previously introduced, the problem of path planning is multi faceted and extremely useful for mobile robot navigation. Our technical approach to solving this problem can be broken down into two parts: path finding and path following. The first being defined as follows: given the current pose of a mobile robot in a known map/environment and a goal pose in the same map find a valid and feasible high-level motion plan through the environment. The second aspect of the technical approach, path following, focuses on translating the high-level path to low-level robot controls in order to have the robot's motion replicate the planned path through the environment. To solve the first challenge of path finding, we rely heavily on well-known search algorithms over space of possible robot poses guided by the dynamics model of the mobile robot and the features of map in order to ensure the feasibility and validity of the planned path. Finally, to tackle the challenge of path following we implement a version of the pure pursuit algorithm. Both of these methods are discussed in greater algorithmic detail throughout the upcoming subsections.

\subsection{Path Finding}

As stated, the goal of path finding is to discover a feasible and valid path through the environment that originates at an staring pose $(x_{\text{init}}, y_{\text{init}}, \theta_{\text{init}})$ and ends at a goal pose $(x^*, y^*, \theta^*)$. In our solution we represent this path as a list of poses $[(x_1, y_1, \theta_1), ..., (x_n, y_n, \theta_n)]$ where the path between any consecutive pair of poses $(x_i, y_i, \theta_i)$ and $(x_{i+1}, y_{i+1}, \theta_{i+1})$ is governed by the bicycle motion model with parameters $p_l, \text{and}, \delta$ where $p_l$ specifies the path length and $\delta$ specifies the steering angle. Given this definition of a path, we need to find the sequence of actions and resultant poses such that $(x_1, y_1, \theta_1) = (x_{\text{init}}, y_{\text{init}}, \theta_{\text{init}})$, $(x_n, y_n, \theta_n) = (x^*, y^*, \theta^*)$ and all poses along the path are not in collision with any obstacles specified by the known environment map. In our specific scenario we assume the map is given as a 2D binary image where a pixel of value 0 represents free space in the environment and 1 represents a prohibited obstacle. Finally, we assume that there is a known conversion between 2D map pixel coordinates and real world environment coordinates. 

A simple algorithmic approach to path finding given this map representation would be to plan a path using search algorithm such as A*, BFS or DFS run directly on the free space in the map starting from the nearest 2D coordinated to $(x_{\text{init}}, y_{\text{init}}, \theta_{\text{init}})$ and finishing at the nearest 2D coordinated to $(x^*, y^*, \theta^*)$. However, this approach encounters two key issues. First, it incorporates no notion of robot heading or dynamics and as such while the path produced may be valid in that it does not collide with obstacles, it is unlikely to be feasible for all but straight paths. To solve this problem of feasibility while maintaining the desirable property of validity we re-frame the problem as a search over a discretized version of the continuous robot configuration space. Specifically, we implement a modified A star search starting from the initial pose and compute neighbors to a given pose $(x, y, \theta)$ using a discrete set of actions $A = \{(p_l, \delta) | \forall p_l \in P, \forall \delta \in D\}$ where $D$ is a user defined set of usable steering angles and $P$ is a user defined set of usable path lengths. Due to the use of actions in this way the edge weights needed for A* are simply set to the path length between neighboring poses, $p_l$, and a simple euclidean distance heuristic to the goal position is used to guide the search overall. These actions are applied to the current pose, $\textbf{x}_{\text{old}}$, to produce feasible neighboring poses $\textbf{x}_{\text{new}}$ in the procedurally generated configuration space graph as follows:

$$\Delta x = \frac{L\sin\left(\frac{p_l\tan\left(\delta\right)}{L}\right)}{\tan\left(\delta\right)}$$

$$\Delta y = \frac{-L\cos\left(\frac{p_l\tan\left(\delta\right)}{L}\right)\ +\ L}{\tan\left(\delta\right)}$$

$$\Delta \theta = \frac{p_l\tan\left(\delta\right)}{L}$$

$$\textbf{x}_{\text{new}} = \begin{bmatrix}
\cos(-\theta_{\text{old}}) & -\sin(-\theta_{\text{old}}) & 0\\ 
\sin(-\theta_{\text{old}}) & \cos(-\theta_{\text{old}}) & 0\\ 
0 & 0 & 1
\end{bmatrix} \begin{bmatrix}
\Delta x\\ 
\Delta y\\ 
\Delta \theta
\end{bmatrix} + \textbf{x}_{\text{old}}$$

where $L$ is a constant parameter specifying the distance between the front and rear axle of the robot. These neighboring poses are then filtered keeping only the valid poses which are not within an object when projected on to the 2D map. While these neighboring poses are generated using continuous functions, for the purposes of keeping track of the nodes and their respective costs during A* search they are discretized to the nearest coordinate on a grid with a user specified real world resolution. The angles are also discretized by remapping an angle $\theta \in [0, 2\pi]$ to $\theta^\prime \in \{0, \frac{2\pi}{N}, \frac{4\pi}{N}, ..., \frac{2N\pi}{N} \}$ where $N$ is the number of angle bins. This discretization in turn makes the search tractable and allows for another two parameters to control the behaviour of the algorithm as speed can be traded for accuracy by increasing or decreasing the search resolution in the angular or spatial domain. 

Overall, this approach enables the planning of feasible and valid plans efficiently while still allowing for user tuning and control of the quality and accuracy of produced paths.




\pagebreak
\section{Experimental Evaluation}


\subsection{Evaluation Takeaways}


\pagebreak
\section{Conclusion}


\section{Lessons Learned}

\subsection{Rohan Wagh}

\subsection{Gabriel Jimenez}


\subsection{Kairo Morton}
During this lab I spent the majority of my time working on the path planning and search aspects of the system. I found this work in particular to be technically challenging and engaging due to the open-ended nature of the problem and the multitude of possible solutions. In the process of developing the path planning algorithm, the most valuable lesson I learned was the importance of creating sandbox simulations and unit tests for my algorithms outside of the ROS framework, as it allowed for quicker and more efficient in developing our solution. However, I did realize that I could have been more helpful and available when it came to integrating the code onto the robot after it was working in simulation. Nevertheless, overall it was a great learning experience and I am excited to possibly improve on the code in the future for use in the final challenge.



\end{document}
